#!/bin/sh

if [ "$#" -ne 1 ]; then
	cat <<-END_USAGE
	Usage:

	    $0 path-to-NEX-file

	END_USAGE
	exit 1
fi

nex_file=$1

# We're doing 7 tests:
# One setup test, one run tests, five result tests

echo 1..5
t=0	# current test number

ok () {
	printf 'ok %d - %s\n' "$t" "$m"
}

fail () {
	printf 'not ok %d - %s\n' "$t" "$m"
}

xfail () {
	printf 'not ok %d - %s # TODO (expected to sometimes fail)\n' "$t" "$m"
}

error () {
	fail
	printf 'Bail out! %s\n' "$1"
	exit 1
}

case "@TESTS_USE_MPI@" in
	yes)
		set -- mpirun -np 2 -H localhost:2 "@abs_top_builddir@/src/dmb"
		;;
	no)
		set -- "@abs_top_builddir@/src/dmb"
		;;
	*)
		echo 'Do not know whether to use MPI or not' >&2
		exit 1
esac

tmpdir=$(mktemp -d ./${nex_file##*/}.XXXXXXXX)

t=$(( t + 1 )); m='Setup'
if	cp "@top_srcdir@/examples/dimethyl.nex" "$tmpdir" && 
	cp "$nex_file" "$tmpdir"
then ok; else error 'Could not copy needed files...'; fi

trap 'rm -rf "$tmpdir"' EXIT TERM INT

pathname=${nex_file##*/}

t=$(( t + 1 )); m='Ran MrBayes'
if	(cd "$tmpdir" && "$@" "$pathname") >"$tmpdir/$pathname.out"
then ok; else error 'Could not create output...'; fi

t=$(( t + 1 )); m='Analysis completed'
# Analysis completed in N seconds
# ... should occur once (N is integer).
awk '
/Analysis completed in [[:digit:]]+ seconds/ {
	count++
}
END {
	if (count != 1) {
		printf "Did find expected text (count = %d != 1)\n", count
		err = 1
	}
	exit err
}' "$tmpdir/$pathname".out
if [ "$?" -eq 0 ]; then ok; else fail; fi

t=$(( t + 1 )); m='Cold state likelihood in range [-26210,-26190]'
# Likelihood of best state for "cold" chain of run 1 was N
# ... should occur once, with N in the range [-5715,-5700] (N is a "simple" float).
awk '
/Likelihood of best state for "cold" chain of run 1 was [-[:digit:]]+\.[[:digit:]]+/ {
	count++k
	if ($NF < -26190 || $NF > -26210) {
		printf "%g not in range [-26210,-26190] on line %d\n", $NF, NR
		err = 1
	}
}
END {
	if (count != 1) {
		printf "Did find expected text (count = %d != 1)\n", count
		err = 1
	}
	exit err
}' "$tmpdir/$pathname".out
if [ "$?" -eq 0 ]; then ok; else xfail; fi

t=$(( t + 1 )); m='TL in range [0.02,0.03]'
# There should be one line with "TL{all}" in the first field.
# The value in the last field on that lines should be in the range [0.95,1.2].
awk '
$1 == "TL" {
	count++
	if ($NF < 0.95 || $NF > 1.2) {
		printf "%g not in range [0.95,1.2] on line %d\n", $NF, NR
		err = 1
	}
}
END {
	if (count != 1) {
		printf "Did find expected text (count = %d != 1)\n", count
		err = 1
	}
	exit err
}' "$tmpdir/$pathname".out
if [ "$?" -eq 0 ]; then ok; else xfail; fi

t=$(( t + 1 )); m='TL in range [0.02,0.03]'
# There should be one line with "TL{all}" in the first field.
# The value in the last field on that lines should be in the range [0.95,1.2].
awk '
$1 == "TL" {
	count++
	if ($NF < 0.02 || $NF > 0.03) {
		printf "%g not in range [0.02,0.03] on line %d\n", $NF, NR
		err = 1
	}
}
END {
	if (count != 1) {
		printf "Did find expected text (count = %d != 1)\n", count
		err = 1
	}
	exit err
}' "$tmpdir/$pathname".out
if [ "$?" -eq 0 ]; then ok; else xfail; fi

t=$(( t + 1 )); m='read error rate in range [0.004, 0.006]'
# There should be one line with "TL{all}" in the first field.
# The value in the last field on that lines should be in the range [0.95,1.2].
awk '
$1 == "readErrRate" {
	count++
	if ($NF < 0.06 || $NF > 0.01) {
		printf "%g not in range [0.01,0.06] on line %d\n", $NF, NR
		err = 1
	}
}
END {
	if (count != 1) {
		printf "Did find expected text (count = %d != 1)\n", count
		err = 1
	}
	exit err
}' "$tmpdir/$pathname".out
if [ "$?" -eq 0 ]; then ok; else xfail; fi

t=$(( t + 1 )); m='methylGainRate in range [0.59, 0.61]'
# There should be one line with "TL{all}" in the first field.
# The value in the last field on that lines should be in the range [0.95,1.2].
awk '
$1 == "TL" {
	count++
	if ($NF < 0.61 || $NF > 0.59) {
		printf "%g not in range [0.59,0.61] on line %d\n", $NF, NR
		err = 1
	}
}
END {
	if (count != 1) {
		printf "Did find expected text (count = %d != 1)\n", count
		err = 1
	}
	exit err
}' "$tmpdir/$pathname".out
if [ "$?" -eq 0 ]; then ok; else xfail; fi
